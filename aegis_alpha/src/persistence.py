"""
TERMINAL - Persistence Layer
================================
SQLite3 wrapper for trade history, signals, and model performance tracking.

Database: data/war_room.db
Tables:
  - signals: All predictions generated by the system
  - trades: Executed trades (paper or live)
  - model_performance: Per-symbol accuracy metrics
"""

import sqlite3
import os
from datetime import datetime
from typing import List, Dict, Optional
import pandas as pd


class Database:
    """SQLite database manager for TERMINAL"""
    
    def __init__(self, db_path: str = 'data/war_room.db'):
        """
        Initialize database connection
        
        Args:
            db_path: Path to SQLite database file
        """
        # Ensure data directory exists
        db_dir = os.path.dirname(db_path)
        if db_dir and not os.path.exists(db_dir):
            os.makedirs(db_dir)
        
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.cursor = self.conn.cursor()
        self._create_tables()
    
    def _create_tables(self):
        """Create database schema if not exists"""
        
        # Signals table - every prediction generated
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS signals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                symbol TEXT NOT NULL,
                price REAL NOT NULL,
                confidence REAL NOT NULL,
                signal TEXT NOT NULL,
                approved INTEGER NOT NULL,
                entry_price REAL,
                stop_loss REAL,
                take_profit REAL,
                executed INTEGER DEFAULT 0,
                reason TEXT
            )
        ''')
        
        # Trades table - actual executions
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS trades (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                symbol TEXT NOT NULL,
                side TEXT NOT NULL,
                entry_price REAL NOT NULL,
                quantity REAL NOT NULL,
                stop_loss REAL,
                take_profit REAL,
                exit_price REAL,
                pnl REAL,
                status TEXT DEFAULT 'OPEN',
                exit_timestamp TEXT,
                notes TEXT
            )
        ''')
        
        # Model performance table - accuracy tracking
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS model_performance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT UNIQUE NOT NULL,
                model_path TEXT NOT NULL,
                accuracy REAL,
                win_rate REAL,
                total_trades INTEGER DEFAULT 0,
                winning_trades INTEGER DEFAULT 0,
                losing_trades INTEGER DEFAULT 0,
                total_pnl REAL DEFAULT 0,
                last_updated TEXT NOT NULL
            )
        ''')
        
        self.conn.commit()
    
    # ============================================================
    # SIGNALS
    # ============================================================
    
    def log_signal(self, symbol: str, signal_data: Dict) -> int:
        """
        Log a trading signal with Atomic Integrity
        """
        try:
            with self.conn:
                cursor = self.conn.cursor()
                cursor.execute('''
                    INSERT INTO signals (
                        timestamp, symbol, price, confidence, signal, approved,
                        entry_price, stop_loss, take_profit, reason
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    datetime.now().isoformat(),
                    symbol,
                    signal_data.get('price', 0),
                    signal_data.get('confidence', 0),
                    signal_data.get('signal', 'HOLD'),
                    1 if signal_data.get('approved', False) else 0,
                    signal_data.get('entry_price'),
                    signal_data.get('stop_loss'),
                    signal_data.get('take_profit'),
                    signal_data.get('reason', 'N/A')
                ))
                return cursor.lastrowid
        except Exception as e:
            print(f"âŒ DB Signal Error: {e}")
            return -1

    def get_signals(self, symbol: Optional[str] = None, limit: int = 100) -> List[Dict]:
        """Get recent signals with Safe Cursor management"""
        try:
            cursor = self.conn.cursor()
            query = 'SELECT * FROM signals'
            params = []
            
            if symbol:
                query += ' WHERE symbol = ?'
                params.append(symbol)
            
            query += ' ORDER BY timestamp DESC LIMIT ?'
            params.append(limit)
            
            cursor.execute(query, params)
            columns = [desc[0] for desc in cursor.description]
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
        except Exception as e:
            print(f"âŒ DB Query Error: {e}")
            return []

    def mark_signal_executed(self, signal_id: int):
        """Mark a signal as executed with Atomic commit"""
        try:
            with self.conn:
                cursor = self.conn.cursor()
                cursor.execute('UPDATE signals SET executed = 1 WHERE id = ?', (signal_id,))
        except Exception as e:
            print(f"âŒ DB Exec Update Error: {e}")
    
    # ============================================================
    # TRADES
    # ============================================================
    
    def log_trade(self, symbol: str, side: str, entry_price: float, 
                   quantity: float, stop_loss: float = None, 
                   take_profit: float = None) -> int:
        """Log a new trade with Atomic Integrity"""
        try:
            with self.conn:
                cursor = self.conn.cursor()
                cursor.execute('''
                    INSERT INTO trades (
                        timestamp, symbol, side, entry_price, quantity,
                        stop_loss, take_profit, status
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, 'OPEN')
                ''', (
                    datetime.now().isoformat(),
                    symbol,
                    side,
                    entry_price,
                    quantity,
                    stop_loss,
                    take_profit
                ))
                return cursor.lastrowid
        except Exception as e:
            print(f"âŒ DB Trade Error: {e}")
            return -1

    def close_trade(self, trade_id: int, exit_price: float, notes: str = None):
        """Close an existing trade and calculate PnL Atomically"""
        try:
            with self.conn:
                cursor = self.conn.cursor()
                cursor.execute('SELECT * FROM trades WHERE id = ?', (trade_id,))
                trade = cursor.fetchone()
                
                if not trade:
                    return 0
                
                # Calculate PnL
                side = trade[3]
                entry_price = trade[4]
                quantity = trade[5]
                pnl = (exit_price - entry_price) * quantity if side == 'BUY' else (entry_price - exit_price) * quantity
                
                cursor.execute('''
                    UPDATE trades 
                    SET exit_price = ?, pnl = ?, status = 'CLOSED',
                        exit_timestamp = ?, notes = ?
                    WHERE id = ?
                ''', (exit_price, pnl, datetime.now().isoformat(), notes, trade_id))
                return pnl
        except Exception as e:
            print(f"âŒ DB Close Error: {e}")
            return 0
    
    def get_trades(self, symbol: Optional[str] = None, status: str = None) -> List[Dict]:
        """Get trades with optional filters"""
        query = 'SELECT * FROM trades WHERE 1=1'
        params = []
        
        if symbol:
            query += ' AND symbol = ?'
            params.append(symbol)
        
        if status:
            query += ' AND status = ?'
            params.append(status)
        
        query += ' ORDER BY timestamp DESC'
        
        self.cursor.execute(query, params)
        columns = [desc[0] for desc in self.cursor.description]
        return [dict(zip(columns, row)) for row in self.cursor.fetchall()]
    
    # ============================================================
    # MODEL PERFORMANCE
    # ============================================================
    
    def update_model_performance(self, symbol: str, model_path: str, 
                                   accuracy: float = None, win_rate: float = None):
        """Update or insert model performance metrics"""
        self.cursor.execute('''
            INSERT INTO model_performance (symbol, model_path, accuracy, win_rate, last_updated)
            VALUES (?, ?, ?, ?, ?)
            ON CONFLICT(symbol) DO UPDATE SET
                model_path = excluded.model_path,
                accuracy = excluded.accuracy,
                win_rate = excluded.win_rate,
                last_updated = excluded.last_updated
        ''', (
            symbol,
            model_path,
            accuracy,
            win_rate,
            datetime.now().isoformat()
        ))
        self.conn.commit()
    
    def get_model_performance(self, symbol: Optional[str] = None) -> List[Dict]:
        """Get model performance metrics"""
        query = 'SELECT * FROM model_performance'
        params = []
        
        if symbol:
            query += ' WHERE symbol = ?'
            params.append(symbol)
        
        self.cursor.execute(query, params)
        columns = [desc[0] for desc in self.cursor.description]
        return [dict(zip(columns, row)) for row in self.cursor.fetchall()]
    
    # ============================================================
    # ANALYTICS
    # ============================================================
    
    def get_statistics(self, symbol: Optional[str] = None) -> Dict:
        """Get trading statistics"""
        query = 'SELECT * FROM trades WHERE status = "CLOSED"'
        params = []
        
        if symbol:
            query += ' AND symbol = ?'
            params.append(symbol)
        
        df = pd.read_sql_query(query, self.conn, params=params)
        
        if df.empty:
            return {
                'total_trades': 0,
                'win_rate': 0,
                'total_pnl': 0,
                'avg_pnl': 0
            }
        
        winning_trades = len(df[df['pnl'] > 0])
        total_trades = len(df)
        
        return {
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': total_trades - winning_trades,
            'win_rate': (winning_trades / total_trades * 100) if total_trades > 0 else 0,
            'total_pnl': df['pnl'].sum(),
            'avg_pnl': df['pnl'].mean(),
            'max_win': df['pnl'].max(),
            'max_loss': df['pnl'].min()
        }
    
    def close(self):
        """Close database connection"""
        self.conn.close()


if __name__ == '__main__':
    # Test the database
    print("ðŸ§ª Testing persistence layer...")
    
    db = Database('data/test_war_room.db')
    
    # Test signal logging
    signal_id = db.log_signal('BTCUSDT', {
        'price': 50000,
        'confidence': 0.75,
        'signal': 'BUY',
        'approved': True,
        'entry_price': 50000,
        'stop_loss': 49000,
        'take_profit': 52000
    })
    print(f"âœ… Signal logged: ID {signal_id}")
    
    # Test trade logging
    trade_id = db.log_trade('BTCUSDT', 'BUY', 50000, 0.1, 49000, 52000)
    print(f"âœ… Trade logged: ID {trade_id}")
    
    # Close trade
    pnl = db.close_trade(trade_id, 51000, 'Manual exit')
    print(f"âœ… Trade closed: PnL ${pnl:.2f}")
    
    # Get stats
    stats = db.get_statistics('BTCUSDT')
    print(f"âœ… Stats: {stats}")
    
    db.close()
    print("\nâœ… Persistence layer test passed!")
